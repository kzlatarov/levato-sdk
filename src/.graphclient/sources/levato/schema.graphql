schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

enum Aggregation_interval {
  hour
  day
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

type BorrowAsPosition {
  id: Bytes!
  position: Bytes!
  asset: Bytes!
  borrowAmount: BigInt!
  scaledATokensMinted: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input BorrowAsPosition_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  position: Bytes
  position_not: Bytes
  position_gt: Bytes
  position_lt: Bytes
  position_gte: Bytes
  position_lte: Bytes
  position_in: [Bytes!]
  position_not_in: [Bytes!]
  position_contains: Bytes
  position_not_contains: Bytes
  asset: Bytes
  asset_not: Bytes
  asset_gt: Bytes
  asset_lt: Bytes
  asset_gte: Bytes
  asset_lte: Bytes
  asset_in: [Bytes!]
  asset_not_in: [Bytes!]
  asset_contains: Bytes
  asset_not_contains: Bytes
  borrowAmount: BigInt
  borrowAmount_not: BigInt
  borrowAmount_gt: BigInt
  borrowAmount_lt: BigInt
  borrowAmount_gte: BigInt
  borrowAmount_lte: BigInt
  borrowAmount_in: [BigInt!]
  borrowAmount_not_in: [BigInt!]
  scaledATokensMinted: BigInt
  scaledATokensMinted_not: BigInt
  scaledATokensMinted_gt: BigInt
  scaledATokensMinted_lt: BigInt
  scaledATokensMinted_gte: BigInt
  scaledATokensMinted_lte: BigInt
  scaledATokensMinted_in: [BigInt!]
  scaledATokensMinted_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [BorrowAsPosition_filter]
  or: [BorrowAsPosition_filter]
}

enum BorrowAsPosition_orderBy {
  id
  position
  asset
  borrowAmount
  scaledATokensMinted
  blockNumber
  blockTimestamp
  transactionHash
}

scalar Bytes

"""
8 bytes signed integer

"""
scalar Int8

type Liquidation {
  id: Bytes!
  liquidator: Bytes!
  position: Bytes!
  borrowedAsset: Bytes!
  debtToRepay: BigInt!
  collateralAsset: Bytes!
  actualSeizedStableAmount: BigInt!
  executionPrice: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input Liquidation_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  liquidator: Bytes
  liquidator_not: Bytes
  liquidator_gt: Bytes
  liquidator_lt: Bytes
  liquidator_gte: Bytes
  liquidator_lte: Bytes
  liquidator_in: [Bytes!]
  liquidator_not_in: [Bytes!]
  liquidator_contains: Bytes
  liquidator_not_contains: Bytes
  position: Bytes
  position_not: Bytes
  position_gt: Bytes
  position_lt: Bytes
  position_gte: Bytes
  position_lte: Bytes
  position_in: [Bytes!]
  position_not_in: [Bytes!]
  position_contains: Bytes
  position_not_contains: Bytes
  borrowedAsset: Bytes
  borrowedAsset_not: Bytes
  borrowedAsset_gt: Bytes
  borrowedAsset_lt: Bytes
  borrowedAsset_gte: Bytes
  borrowedAsset_lte: Bytes
  borrowedAsset_in: [Bytes!]
  borrowedAsset_not_in: [Bytes!]
  borrowedAsset_contains: Bytes
  borrowedAsset_not_contains: Bytes
  debtToRepay: BigInt
  debtToRepay_not: BigInt
  debtToRepay_gt: BigInt
  debtToRepay_lt: BigInt
  debtToRepay_gte: BigInt
  debtToRepay_lte: BigInt
  debtToRepay_in: [BigInt!]
  debtToRepay_not_in: [BigInt!]
  collateralAsset: Bytes
  collateralAsset_not: Bytes
  collateralAsset_gt: Bytes
  collateralAsset_lt: Bytes
  collateralAsset_gte: Bytes
  collateralAsset_lte: Bytes
  collateralAsset_in: [Bytes!]
  collateralAsset_not_in: [Bytes!]
  collateralAsset_contains: Bytes
  collateralAsset_not_contains: Bytes
  actualSeizedStableAmount: BigInt
  actualSeizedStableAmount_not: BigInt
  actualSeizedStableAmount_gt: BigInt
  actualSeizedStableAmount_lt: BigInt
  actualSeizedStableAmount_gte: BigInt
  actualSeizedStableAmount_lte: BigInt
  actualSeizedStableAmount_in: [BigInt!]
  actualSeizedStableAmount_not_in: [BigInt!]
  executionPrice: BigInt
  executionPrice_not: BigInt
  executionPrice_gt: BigInt
  executionPrice_lt: BigInt
  executionPrice_gte: BigInt
  executionPrice_lte: BigInt
  executionPrice_in: [BigInt!]
  executionPrice_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Liquidation_filter]
  or: [Liquidation_filter]
}

enum Liquidation_orderBy {
  id
  liquidator
  position
  borrowedAsset
  debtToRepay
  collateralAsset
  actualSeizedStableAmount
  executionPrice
  blockNumber
  blockTimestamp
  transactionHash
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Position {
  id: Bytes!
  trader: Bytes!
  collateral: Bytes!
  stable: Bytes!
  lendingProtocol: Int!
  fundedCollateralAmount: BigInt!
}

type PositionClosed {
  id: Bytes!
  position: Bytes!
  withdrawAmount: BigInt!
  equityAmountBefore: BigInt!
  executionPrice: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input PositionClosed_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  position: Bytes
  position_not: Bytes
  position_gt: Bytes
  position_lt: Bytes
  position_gte: Bytes
  position_lte: Bytes
  position_in: [Bytes!]
  position_not_in: [Bytes!]
  position_contains: Bytes
  position_not_contains: Bytes
  withdrawAmount: BigInt
  withdrawAmount_not: BigInt
  withdrawAmount_gt: BigInt
  withdrawAmount_lt: BigInt
  withdrawAmount_gte: BigInt
  withdrawAmount_lte: BigInt
  withdrawAmount_in: [BigInt!]
  withdrawAmount_not_in: [BigInt!]
  equityAmountBefore: BigInt
  equityAmountBefore_not: BigInt
  equityAmountBefore_gt: BigInt
  equityAmountBefore_lt: BigInt
  equityAmountBefore_gte: BigInt
  equityAmountBefore_lte: BigInt
  equityAmountBefore_in: [BigInt!]
  equityAmountBefore_not_in: [BigInt!]
  executionPrice: BigInt
  executionPrice_not: BigInt
  executionPrice_gt: BigInt
  executionPrice_lt: BigInt
  executionPrice_gte: BigInt
  executionPrice_lte: BigInt
  executionPrice_in: [BigInt!]
  executionPrice_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PositionClosed_filter]
  or: [PositionClosed_filter]
}

enum PositionClosed_orderBy {
  id
  position
  withdrawAmount
  equityAmountBefore
  executionPrice
  blockNumber
  blockTimestamp
  transactionHash
}

type PositionCreated {
  id: Bytes!
  user: Bytes!
  position: Bytes!
  collateral: Bytes!
  stable: Bytes!
  lendingProtocol: Int!
  executionPrice: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  usdcPriceOnCreation: BigInt!
}

input PositionCreated_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  user: Bytes
  user_not: Bytes
  user_gt: Bytes
  user_lt: Bytes
  user_gte: Bytes
  user_lte: Bytes
  user_in: [Bytes!]
  user_not_in: [Bytes!]
  user_contains: Bytes
  user_not_contains: Bytes
  position: Bytes
  position_not: Bytes
  position_gt: Bytes
  position_lt: Bytes
  position_gte: Bytes
  position_lte: Bytes
  position_in: [Bytes!]
  position_not_in: [Bytes!]
  position_contains: Bytes
  position_not_contains: Bytes
  collateral: Bytes
  collateral_not: Bytes
  collateral_gt: Bytes
  collateral_lt: Bytes
  collateral_gte: Bytes
  collateral_lte: Bytes
  collateral_in: [Bytes!]
  collateral_not_in: [Bytes!]
  collateral_contains: Bytes
  collateral_not_contains: Bytes
  stable: Bytes
  stable_not: Bytes
  stable_gt: Bytes
  stable_lt: Bytes
  stable_gte: Bytes
  stable_lte: Bytes
  stable_in: [Bytes!]
  stable_not_in: [Bytes!]
  stable_contains: Bytes
  stable_not_contains: Bytes
  lendingProtocol: Int
  lendingProtocol_not: Int
  lendingProtocol_gt: Int
  lendingProtocol_lt: Int
  lendingProtocol_gte: Int
  lendingProtocol_lte: Int
  lendingProtocol_in: [Int!]
  lendingProtocol_not_in: [Int!]
  executionPrice: BigInt
  executionPrice_not: BigInt
  executionPrice_gt: BigInt
  executionPrice_lt: BigInt
  executionPrice_gte: BigInt
  executionPrice_lte: BigInt
  executionPrice_in: [BigInt!]
  executionPrice_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  usdcPriceOnCreation: BigInt
  usdcPriceOnCreation_not: BigInt
  usdcPriceOnCreation_gt: BigInt
  usdcPriceOnCreation_lt: BigInt
  usdcPriceOnCreation_gte: BigInt
  usdcPriceOnCreation_lte: BigInt
  usdcPriceOnCreation_in: [BigInt!]
  usdcPriceOnCreation_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PositionCreated_filter]
  or: [PositionCreated_filter]
}

enum PositionCreated_orderBy {
  id
  user
  position
  collateral
  stable
  lendingProtocol
  executionPrice
  blockNumber
  blockTimestamp
  transactionHash
  usdcPriceOnCreation
}

type PositionFunded {
  id: Bytes!
  position: Bytes!
  fundingAsset: Bytes!
  fundingAmount: BigInt!
  totalCollateralAmount: BigInt!
  collateralAmountFunded: BigInt!
  executionPrice: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input PositionFunded_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  position: Bytes
  position_not: Bytes
  position_gt: Bytes
  position_lt: Bytes
  position_gte: Bytes
  position_lte: Bytes
  position_in: [Bytes!]
  position_not_in: [Bytes!]
  position_contains: Bytes
  position_not_contains: Bytes
  fundingAsset: Bytes
  fundingAsset_not: Bytes
  fundingAsset_gt: Bytes
  fundingAsset_lt: Bytes
  fundingAsset_gte: Bytes
  fundingAsset_lte: Bytes
  fundingAsset_in: [Bytes!]
  fundingAsset_not_in: [Bytes!]
  fundingAsset_contains: Bytes
  fundingAsset_not_contains: Bytes
  fundingAmount: BigInt
  fundingAmount_not: BigInt
  fundingAmount_gt: BigInt
  fundingAmount_lt: BigInt
  fundingAmount_gte: BigInt
  fundingAmount_lte: BigInt
  fundingAmount_in: [BigInt!]
  fundingAmount_not_in: [BigInt!]
  totalCollateralAmount: BigInt
  totalCollateralAmount_not: BigInt
  totalCollateralAmount_gt: BigInt
  totalCollateralAmount_lt: BigInt
  totalCollateralAmount_gte: BigInt
  totalCollateralAmount_lte: BigInt
  totalCollateralAmount_in: [BigInt!]
  totalCollateralAmount_not_in: [BigInt!]
  collateralAmountFunded: BigInt
  collateralAmountFunded_not: BigInt
  collateralAmountFunded_gt: BigInt
  collateralAmountFunded_lt: BigInt
  collateralAmountFunded_gte: BigInt
  collateralAmountFunded_lte: BigInt
  collateralAmountFunded_in: [BigInt!]
  collateralAmountFunded_not_in: [BigInt!]
  executionPrice: BigInt
  executionPrice_not: BigInt
  executionPrice_gt: BigInt
  executionPrice_lt: BigInt
  executionPrice_gte: BigInt
  executionPrice_lte: BigInt
  executionPrice_in: [BigInt!]
  executionPrice_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PositionFunded_filter]
  or: [PositionFunded_filter]
}

enum PositionFunded_orderBy {
  id
  position
  fundingAsset
  fundingAmount
  totalCollateralAmount
  collateralAmountFunded
  executionPrice
  blockNumber
  blockTimestamp
  transactionHash
}

type PositionRatioAdjusted {
  id: Bytes!
  position: Bytes!
  targetRatio: BigInt!
  realizedRatio: BigInt!
  equityAmountBefore: BigInt!
  equityAmountAfter: BigInt!
  executionPrice: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input PositionRatioAdjusted_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  position: Bytes
  position_not: Bytes
  position_gt: Bytes
  position_lt: Bytes
  position_gte: Bytes
  position_lte: Bytes
  position_in: [Bytes!]
  position_not_in: [Bytes!]
  position_contains: Bytes
  position_not_contains: Bytes
  targetRatio: BigInt
  targetRatio_not: BigInt
  targetRatio_gt: BigInt
  targetRatio_lt: BigInt
  targetRatio_gte: BigInt
  targetRatio_lte: BigInt
  targetRatio_in: [BigInt!]
  targetRatio_not_in: [BigInt!]
  realizedRatio: BigInt
  realizedRatio_not: BigInt
  realizedRatio_gt: BigInt
  realizedRatio_lt: BigInt
  realizedRatio_gte: BigInt
  realizedRatio_lte: BigInt
  realizedRatio_in: [BigInt!]
  realizedRatio_not_in: [BigInt!]
  equityAmountBefore: BigInt
  equityAmountBefore_not: BigInt
  equityAmountBefore_gt: BigInt
  equityAmountBefore_lt: BigInt
  equityAmountBefore_gte: BigInt
  equityAmountBefore_lte: BigInt
  equityAmountBefore_in: [BigInt!]
  equityAmountBefore_not_in: [BigInt!]
  equityAmountAfter: BigInt
  equityAmountAfter_not: BigInt
  equityAmountAfter_gt: BigInt
  equityAmountAfter_lt: BigInt
  equityAmountAfter_gte: BigInt
  equityAmountAfter_lte: BigInt
  equityAmountAfter_in: [BigInt!]
  equityAmountAfter_not_in: [BigInt!]
  executionPrice: BigInt
  executionPrice_not: BigInt
  executionPrice_gt: BigInt
  executionPrice_lt: BigInt
  executionPrice_gte: BigInt
  executionPrice_lte: BigInt
  executionPrice_in: [BigInt!]
  executionPrice_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PositionRatioAdjusted_filter]
  or: [PositionRatioAdjusted_filter]
}

enum PositionRatioAdjusted_orderBy {
  id
  position
  targetRatio
  realizedRatio
  equityAmountBefore
  equityAmountAfter
  executionPrice
  blockNumber
  blockTimestamp
  transactionHash
}

input Position_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  trader: Bytes
  trader_not: Bytes
  trader_gt: Bytes
  trader_lt: Bytes
  trader_gte: Bytes
  trader_lte: Bytes
  trader_in: [Bytes!]
  trader_not_in: [Bytes!]
  trader_contains: Bytes
  trader_not_contains: Bytes
  collateral: Bytes
  collateral_not: Bytes
  collateral_gt: Bytes
  collateral_lt: Bytes
  collateral_gte: Bytes
  collateral_lte: Bytes
  collateral_in: [Bytes!]
  collateral_not_in: [Bytes!]
  collateral_contains: Bytes
  collateral_not_contains: Bytes
  stable: Bytes
  stable_not: Bytes
  stable_gt: Bytes
  stable_lt: Bytes
  stable_gte: Bytes
  stable_lte: Bytes
  stable_in: [Bytes!]
  stable_not_in: [Bytes!]
  stable_contains: Bytes
  stable_not_contains: Bytes
  lendingProtocol: Int
  lendingProtocol_not: Int
  lendingProtocol_gt: Int
  lendingProtocol_lt: Int
  lendingProtocol_gte: Int
  lendingProtocol_lte: Int
  lendingProtocol_in: [Int!]
  lendingProtocol_not_in: [Int!]
  fundedCollateralAmount: BigInt
  fundedCollateralAmount_not: BigInt
  fundedCollateralAmount_gt: BigInt
  fundedCollateralAmount_lt: BigInt
  fundedCollateralAmount_gte: BigInt
  fundedCollateralAmount_lte: BigInt
  fundedCollateralAmount_in: [BigInt!]
  fundedCollateralAmount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Position_filter]
  or: [Position_filter]
}

enum Position_orderBy {
  id
  trader
  collateral
  stable
  lendingProtocol
  fundedCollateralAmount
}

type Query {
  position(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Position
  positions(
    skip: Int = 0
    first: Int = 100
    orderBy: Position_orderBy
    orderDirection: OrderDirection
    where: Position_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Position!]!
  positionCreated(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PositionCreated
  positionCreateds(
    skip: Int = 0
    first: Int = 100
    orderBy: PositionCreated_orderBy
    orderDirection: OrderDirection
    where: PositionCreated_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PositionCreated!]!
  positionFunded(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PositionFunded
  positionFundeds(
    skip: Int = 0
    first: Int = 100
    orderBy: PositionFunded_orderBy
    orderDirection: OrderDirection
    where: PositionFunded_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PositionFunded!]!
  positionRatioAdjusted(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PositionRatioAdjusted
  positionRatioAdjusteds(
    skip: Int = 0
    first: Int = 100
    orderBy: PositionRatioAdjusted_orderBy
    orderDirection: OrderDirection
    where: PositionRatioAdjusted_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PositionRatioAdjusted!]!
  positionClosed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PositionClosed
  positionCloseds(
    skip: Int = 0
    first: Int = 100
    orderBy: PositionClosed_orderBy
    orderDirection: OrderDirection
    where: PositionClosed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PositionClosed!]!
  borrowAsPosition(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BorrowAsPosition
  borrowAsPositions(
    skip: Int = 0
    first: Int = 100
    orderBy: BorrowAsPosition_orderBy
    orderDirection: OrderDirection
    where: BorrowAsPosition_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BorrowAsPosition!]!
  liquidation(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Liquidation
  liquidations(
    skip: Int = 0
    first: Int = 100
    orderBy: Liquidation_orderBy
    orderDirection: OrderDirection
    where: Liquidation_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Liquidation!]!
  repayAsPosition(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RepayAsPosition
  repayAsPositions(
    skip: Int = 0
    first: Int = 100
    orderBy: RepayAsPosition_orderBy
    orderDirection: OrderDirection
    where: RepayAsPosition_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RepayAsPosition!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type RepayAsPosition {
  id: Bytes!
  position: Bytes!
  asset: Bytes!
  borrowAmount: BigInt!
  scaledATokensBurnt: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input RepayAsPosition_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  position: Bytes
  position_not: Bytes
  position_gt: Bytes
  position_lt: Bytes
  position_gte: Bytes
  position_lte: Bytes
  position_in: [Bytes!]
  position_not_in: [Bytes!]
  position_contains: Bytes
  position_not_contains: Bytes
  asset: Bytes
  asset_not: Bytes
  asset_gt: Bytes
  asset_lt: Bytes
  asset_gte: Bytes
  asset_lte: Bytes
  asset_in: [Bytes!]
  asset_not_in: [Bytes!]
  asset_contains: Bytes
  asset_not_contains: Bytes
  borrowAmount: BigInt
  borrowAmount_not: BigInt
  borrowAmount_gt: BigInt
  borrowAmount_lt: BigInt
  borrowAmount_gte: BigInt
  borrowAmount_lte: BigInt
  borrowAmount_in: [BigInt!]
  borrowAmount_not_in: [BigInt!]
  scaledATokensBurnt: BigInt
  scaledATokensBurnt_not: BigInt
  scaledATokensBurnt_gt: BigInt
  scaledATokensBurnt_lt: BigInt
  scaledATokensBurnt_gte: BigInt
  scaledATokensBurnt_lte: BigInt
  scaledATokensBurnt_in: [BigInt!]
  scaledATokensBurnt_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [RepayAsPosition_filter]
  or: [RepayAsPosition_filter]
}

enum RepayAsPosition_orderBy {
  id
  position
  asset
  borrowAmount
  scaledATokensBurnt
  blockNumber
  blockTimestamp
  transactionHash
}

type Subscription {
  position(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Position
  positions(
    skip: Int = 0
    first: Int = 100
    orderBy: Position_orderBy
    orderDirection: OrderDirection
    where: Position_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Position!]!
  positionCreated(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PositionCreated
  positionCreateds(
    skip: Int = 0
    first: Int = 100
    orderBy: PositionCreated_orderBy
    orderDirection: OrderDirection
    where: PositionCreated_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PositionCreated!]!
  positionFunded(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PositionFunded
  positionFundeds(
    skip: Int = 0
    first: Int = 100
    orderBy: PositionFunded_orderBy
    orderDirection: OrderDirection
    where: PositionFunded_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PositionFunded!]!
  positionRatioAdjusted(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PositionRatioAdjusted
  positionRatioAdjusteds(
    skip: Int = 0
    first: Int = 100
    orderBy: PositionRatioAdjusted_orderBy
    orderDirection: OrderDirection
    where: PositionRatioAdjusted_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PositionRatioAdjusted!]!
  positionClosed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PositionClosed
  positionCloseds(
    skip: Int = 0
    first: Int = 100
    orderBy: PositionClosed_orderBy
    orderDirection: OrderDirection
    where: PositionClosed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PositionClosed!]!
  borrowAsPosition(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BorrowAsPosition
  borrowAsPositions(
    skip: Int = 0
    first: Int = 100
    orderBy: BorrowAsPosition_orderBy
    orderDirection: OrderDirection
    where: BorrowAsPosition_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BorrowAsPosition!]!
  liquidation(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Liquidation
  liquidations(
    skip: Int = 0
    first: Int = 100
    orderBy: Liquidation_orderBy
    orderDirection: OrderDirection
    where: Liquidation_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Liquidation!]!
  repayAsPosition(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RepayAsPosition
  repayAsPositions(
    skip: Int = 0
    first: Int = 100
    orderBy: RepayAsPosition_orderBy
    orderDirection: OrderDirection
    where: RepayAsPosition_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RepayAsPosition!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

"""
A string representation of microseconds UNIX timestamp (16 digits)

"""
scalar Timestamp

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: Bytes
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}